var documenterSearchIndex = {"docs":
[{"location":"docstring/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstring/","page":"Docstrings","title":"Docstrings","text":"Modules = [EltypeExtensions]","category":"page"},{"location":"docstring/#EltypeExtensions._to_basetype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T, S}","page":"Docstrings","title":"EltypeExtensions._to_basetype","text":"_to_basetype(T::Type, S::Type)\n\nConvert type S to have the basetype of T.\n\n\n\n\n\n","category":"method"},{"location":"docstring/#EltypeExtensions._to_eltype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T, S}","page":"Docstrings","title":"EltypeExtensions._to_eltype","text":"_to_eltype(T, S)\n\nConvert type S to have the eltype of T. See also convert_eltype.\n\n\n\n\n\n","category":"method"},{"location":"docstring/#EltypeExtensions._to_precisiontype-Union{Tuple{T}, Tuple{Type{T}, Type{Complex}}} where T","page":"Docstrings","title":"EltypeExtensions._to_precisiontype","text":"_to_precisiontype(T::Type, S::Type)\n\nConvert type S to have the precisiontype of T. An exception is that if T<:Integer, then Rational will also be unwrapped.\n\nExamples\n\njulia> _to_precisiontype(Float64, Complex{Rational{Int}})\nComplexF64 (alias for Complex{Float64})\n\njulia> _to_precisiontype(BigFloat, Matrix{Complex{Bool}})\nMatrix{Complex{BigFloat}} (alias for Array{Complex{BigFloat}, 2})\n\njulia> _to_precisiontype(Int, Complex{Rational{BigInt}})\nComplex{Rational{Int64}}\n\n\n\n\n\n","category":"method"},{"location":"docstring/#EltypeExtensions.basetype-Tuple{Any}","page":"Docstrings","title":"EltypeExtensions.basetype","text":"basetype(T::Type)\n\nRecursively apply eltype to T until convergence.\n\nExamples\n\njulia> basetype(Matrix{BitArray})\nBool\n\njulia> basetype(Vector{Set{Complex{Float64}}})\nComplexF64 (alias for Complex{Float64})\n\njulia> basetype([1:n for n in 1:10])\nInt64\n\n\n\n\n\n","category":"method"},{"location":"docstring/#EltypeExtensions.convert_basetype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, S}} where {T, S}","page":"Docstrings","title":"EltypeExtensions.convert_basetype","text":"convert_basetype(T::Type, A)\n\nSimilar to convert(T, A), but T refers to the basetype.\n\n\n\n\n\n","category":"method"},{"location":"docstring/#EltypeExtensions.convert_eltype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, S}} where {T, S}","page":"Docstrings","title":"EltypeExtensions.convert_eltype","text":"convert_eltype(T, A)\n\nSimilar to convert(T, A), but T refers to the eltype. See also _to_eltype.\n\nExamples\n\njulia> convert_eltype(Float64, 1:10)\n1.0:1.0:10.0\n\njulia> typeof(convert_eltype(Float64, rand(Int, 3, 3)))\nMatrix{Float64} (alias for Array{Float64, 2})\n\n\n\n\n\n","category":"method"},{"location":"docstring/#EltypeExtensions.convert_precisiontype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, S}} where {T, S}","page":"Docstrings","title":"EltypeExtensions.convert_precisiontype","text":"convert_precisiontype(T::Type, A, prec)\n\nConvert A to have the precisiontype of T. prec is optional.\n\nWhen T has static precision (e.g. Float64), prec has no effect.\nWhen T has dynamic precision (e.g. BigFloat), prec specifies the precision of conversion. When prec is not provided, the precision is decided by the external setup from T.\nWhen T is an integer, the conversion will dig into Rational as well. In contrast, since Rational as a whole is more \"precise\" than an integer, precisiontype doesn't unwrap Rational.\n\nExamples\n\njulia> convert_precisiontype(BigFloat, 1//3+im, 128)\n0.3333333333333333333333333333333333333338 + 1.0im\n\njulia> convert_precisiontype(Float16, [[m/n for n in 1:3] for m in 1:3])\n3-element Vector{Vector{Float16}}:\n [1.0, 0.5, 0.3333]\n [2.0, 1.0, 0.6665]\n [3.0, 1.5, 1.0]\n\n\n\n\n\n","category":"method"},{"location":"docstring/#EltypeExtensions.precisiontype-Tuple{Any}","page":"Docstrings","title":"EltypeExtensions.precisiontype","text":"precisiontype(T::Type)\n\nReturns the type that decides the precision of T. The difference from basetype is that precisiontype unwraps composite basetypes such as Complex and that precisiontype is not generalised.\n\nExamples\n\njulia> precisiontype(Complex{Float32})\nFloat32\n\njulia> precisiontype(Matrix{ComplexF64})\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"#EltypeExtensions.jl","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"","category":"section"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"EltypeExtensions.jl is a mini toolbox for eltype-related conversions. The motivation of this package comes from manipulating (nested) arrays with different eltypes. However if you have any reasonable idea that works on other instances, feel free to write an issue/pull request.","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"We note that this package has some overlap with TypeUtils.jl and Unitless.jl.","category":"page"},{"location":"#Introduction","page":"EltypeExtensions.jl","title":"Introduction","text":"","category":"section"},{"location":"#convert_eltype-and-_to_eltype","page":"EltypeExtensions.jl","title":"convert_eltype and _to_eltype","text":"","category":"section"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"convert_eltype(T, x) works like convert(T, x), except that T refers to the eltype of the result. This can be useful for generic codes.","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"It should be always true that convert_eltype(T, x) isa _to_eltype(T, typeof(x)). However, since convert_eltype and _to_eltype use different routines, it's possible that the equality doesn't hold for some types. Please submit an issue or PR if that happens.","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"If typeof(x) is not in Base or stdlib, the package who owns the type should implement corresponding _to_eltype or convert_eltype. convert_eltype has fallbacks, in which case it could be unnecessary:","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"For a subtype of AbstractArray, convert_eltype calls the constructor AbstractArray{T} and _to_eltype returns Array.\nFor a subtype of AbstractUnitRange, convert_eltype calls the constructor AbstractUnitRange{T}.\nFor a subtype of AbstractRange, convert_eltype uses broadcast through map.\nFor a Tuple, convert_eltype uses dot broadcast.\nFor other types, convert_eltype calls convert and _to_eltype.","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"However, _to_eltype must be implemented for each type to support convert_basetype and convert_precisiontype. The following types from Base and stdlib are explicitly supported by _to_eltype:","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"AbstractArray, AbstractDict, AbstractSet, Adjoint, Bidiagonal, BitArray, CartesianIndices, Diagonal, Dict, Hermitian, Set, StepRangeLen, Symmetric, SymTridiagonal, Transpose, TwicePrecision, UnitRange","category":"page"},{"location":"#basetype-and-precisiontype","page":"EltypeExtensions.jl","title":"basetype and precisiontype","text":"","category":"section"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"The basetype is used for nested collections, where eltype is repeatedly applied until the bottom. precisiontype has a similar idea, but goes deeper when possible. precisiontype is used to manipulate the accuracy of (nested) collections.","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"using EltypeExtensions","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"basetype(Set{Matrix{Vector{Matrix{Complex{Rational{Int}}}}}})\nprecisiontype(Set{Matrix{Vector{Matrix{Complex{Rational{Int}}}}}})","category":"page"},{"location":"#Method-naming-convention","page":"EltypeExtensions.jl","title":"Method naming convention","text":"","category":"section"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"sometype(T) gets the sometype of type T.\nsometype(x) = sometype(typeof(x)) is also provided for convenience.\n_to_sometype(T,S) converts the type S to have the sometype of T.\nconvert_sometype(T,A) converts A to have the sometype of T.","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"where some can be el, base and precision.","category":"page"},{"location":"#On-convert_precisiontype","page":"EltypeExtensions.jl","title":"On convert_precisiontype","text":"","category":"section"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"convert_precisiontype accepts an optional third argument prec. ","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"When T has static precision, prec has no effect.\nWhen T has dynamic precision, prec specifies the precision of conversion. When prec is not provided, the precision is decided by the external setup from T. The difference is significant when convert_precisiontype is called by another function:\nprecision(BigFloat)\nf(x) = convert_precisiontype(BigFloat, x, 256)\ng(x) = convert_precisiontype(BigFloat, x)\nsetprecision(128)\nf(π) # static precision\ng(π) # precision varies with the global setting\nWhen T is an integer, the conversion will dig into Rational as well. In contrast, since Rational as a whole is more \"precise\" than an integer, precisiontype doesn't unwrap Rational.\nprecisiontype(convert_precisiontype(Int128, Int8(1)//Int8(2)))","category":"page"},{"location":"#Notable-behaviours","page":"EltypeExtensions.jl","title":"Notable behaviours","text":"","category":"section"},{"location":"#Ranges","page":"EltypeExtensions.jl","title":"Ranges","text":"","category":"section"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"Ranges in Julia are not consistently processed:","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"r = StepRange(1,1,5)\nFloat64.(r) |> typeof\nmap(Float64,r) |> typeof","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"We adapt _to_eltype to the return type of Base.map:","category":"page"},{"location":"","page":"EltypeExtensions.jl","title":"EltypeExtensions.jl","text":"_to_eltype(Float64, StepRange{Int,Int})","category":"page"}]
}
